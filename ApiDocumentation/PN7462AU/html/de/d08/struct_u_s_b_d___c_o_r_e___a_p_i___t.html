<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PN7462AU FW API Guide: USBD_CORE_API_T Struct Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../nxp_logo_s.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PN7462AU FW API Guide
   &#160;<span id="projectnumber">v04.14.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('de/d08/struct_u_s_b_d___c_o_r_e___a_p_i___t.html','../../');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">USBD_CORE_API_T Struct Reference<div class="ingroups"><a class="el" href="../../da/d5b/group___group___u_s_b_d.html">USB Library</a> &raquo; <a class="el" href="../../d0/d8f/group___u_s_b_d___core.html">USB Core Layer</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>USBD stack Core API functions structure.  
 <a href="../../de/d08/struct_u_s_b_d___c_o_r_e___a_p_i___t.html#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for USBD_CORE_API_T:</div>
<div class="dyncontent">
<div class="center"><img src="../../d0/d1d/struct_u_s_b_d___c_o_r_e___a_p_i___t__coll__graph.png" border="0" usemap="#_u_s_b_d___c_o_r_e___a_p_i___t_coll__map" alt="Collaboration graph"/></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a651891ae3d6612f6f566384b3d681e36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d41/error_8h.html#a905255056c349318139d94aa4523d516">ErrorCode_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d08/struct_u_s_b_d___c_o_r_e___a_p_i___t.html#a651891ae3d6612f6f566384b3d681e36">RegisterClassHandler</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, <a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gaa578d29a85226108ef62c6d5c325b742">USB_EP_HANDLER_T</a> pfn, void *data)</td></tr>
<tr class="memdesc:a651891ae3d6612f6f566384b3d681e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to register class specific EP0 event handler with USB device stack.  <a href="#a651891ae3d6612f6f566384b3d681e36">More...</a><br /></td></tr>
<tr class="separator:a651891ae3d6612f6f566384b3d681e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305d05fbc2d0c748b87edcd986bfb767"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d41/error_8h.html#a905255056c349318139d94aa4523d516">ErrorCode_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d08/struct_u_s_b_d___c_o_r_e___a_p_i___t.html#a305d05fbc2d0c748b87edcd986bfb767">RegisterEpHandler</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t ep_index, <a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gaa578d29a85226108ef62c6d5c325b742">USB_EP_HANDLER_T</a> pfn, void *data)</td></tr>
<tr class="memdesc:a305d05fbc2d0c748b87edcd986bfb767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to register interrupt/event handler for the requested endpoint with USB device stack.  <a href="#a305d05fbc2d0c748b87edcd986bfb767">More...</a><br /></td></tr>
<tr class="separator:a305d05fbc2d0c748b87edcd986bfb767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373376ee1855114095288c907687b421"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d08/struct_u_s_b_d___c_o_r_e___a_p_i___t.html#a373376ee1855114095288c907687b421">SetupStage</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb)</td></tr>
<tr class="memdesc:a373376ee1855114095288c907687b421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set EP0 state machine in setup state.  <a href="#a373376ee1855114095288c907687b421">More...</a><br /></td></tr>
<tr class="separator:a373376ee1855114095288c907687b421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e05c41e0070d3e706ae98e048e4384"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d08/struct_u_s_b_d___c_o_r_e___a_p_i___t.html#ab1e05c41e0070d3e706ae98e048e4384">DataInStage</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb)</td></tr>
<tr class="memdesc:ab1e05c41e0070d3e706ae98e048e4384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set EP0 state machine in data_in state.  <a href="#ab1e05c41e0070d3e706ae98e048e4384">More...</a><br /></td></tr>
<tr class="separator:ab1e05c41e0070d3e706ae98e048e4384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6e7a43f616cdcbf9e193da25df684a"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d08/struct_u_s_b_d___c_o_r_e___a_p_i___t.html#aff6e7a43f616cdcbf9e193da25df684a">DataOutStage</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb)</td></tr>
<tr class="memdesc:aff6e7a43f616cdcbf9e193da25df684a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set EP0 state machine in data_out state.  <a href="#aff6e7a43f616cdcbf9e193da25df684a">More...</a><br /></td></tr>
<tr class="separator:aff6e7a43f616cdcbf9e193da25df684a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714fc392b856668bf6422cfb1ef1d74c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d08/struct_u_s_b_d___c_o_r_e___a_p_i___t.html#a714fc392b856668bf6422cfb1ef1d74c">StatusInStage</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb)</td></tr>
<tr class="memdesc:a714fc392b856668bf6422cfb1ef1d74c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set EP0 state machine in status_in state.  <a href="#a714fc392b856668bf6422cfb1ef1d74c">More...</a><br /></td></tr>
<tr class="separator:a714fc392b856668bf6422cfb1ef1d74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c49c88a0f39ad432b7ddd03ae449403"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d08/struct_u_s_b_d___c_o_r_e___a_p_i___t.html#a3c49c88a0f39ad432b7ddd03ae449403">StatusOutStage</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb)</td></tr>
<tr class="memdesc:a3c49c88a0f39ad432b7ddd03ae449403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set EP0 state machine in status_out state.  <a href="#a3c49c88a0f39ad432b7ddd03ae449403">More...</a><br /></td></tr>
<tr class="separator:a3c49c88a0f39ad432b7ddd03ae449403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfe3149090b63dd0334634f5f08b002"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d08/struct_u_s_b_d___c_o_r_e___a_p_i___t.html#adbfe3149090b63dd0334634f5f08b002">StallEp0</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb)</td></tr>
<tr class="memdesc:adbfe3149090b63dd0334634f5f08b002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set EP0 state machine in stall state.  <a href="#adbfe3149090b63dd0334634f5f08b002">More...</a><br /></td></tr>
<tr class="separator:adbfe3149090b63dd0334634f5f08b002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c164125955a57eacb5e463a566e39e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d41/error_8h.html#a905255056c349318139d94aa4523d516">ErrorCode_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d08/struct_u_s_b_d___c_o_r_e___a_p_i___t.html#a48c164125955a57eacb5e463a566e39e">GetEpHandler</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t ep_index, <a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gaa578d29a85226108ef62c6d5c325b742">USB_EP_HANDLER_T</a> *ep_handler, void **data)</td></tr>
<tr class="memdesc:a48c164125955a57eacb5e463a566e39e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get default EP handler and its parameter for a particular endpoint.  <a href="#a48c164125955a57eacb5e463a566e39e">More...</a><br /></td></tr>
<tr class="separator:a48c164125955a57eacb5e463a566e39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>USBD stack Core API functions structure. </p>
<p>This module exposes functions which interact directly with USB device stack's core layer. The application layer uses this component when it has to implement custom class function driver or standard class function driver which is not part of the current USB device stack. The functions exposed by this interface are to register class specific EP0 handlers and corresponding utility functions to manipulate EP0 state machine of the stack. This interface also exposes function to register custom endpoint interrupt handler. </p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="a651891ae3d6612f6f566384b3d681e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a651891ae3d6612f6f566384b3d681e36">&sect;&nbsp;</a></span>RegisterClassHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d41/error_8h.html#a905255056c349318139d94aa4523d516">ErrorCode_t</a> USBD_CORE_API_T::RegisterClassHandler</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to register class specific EP0 event handler with USB device stack. </p>
<p>The application layer uses this function when it has to register the custom class's EP0 handler. The stack calls all the registered class handlers on any EP0 event before going through default handling of the event. This gives the class handlers to implement class specific request handlers and also to override the default stack handling for a particular event targeted to the interface. Check <a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gaa578d29a85226108ef62c6d5c325b742">USB_EP_HANDLER_T</a> for more details on how the callback function should be implemented. Also application layer could use this function to register EP0 handler which responds to vendor specific requests.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pfn</td><td>Class specific EP0 handler function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data which will be passed when callback function is called by the stack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <a class="el" href="../../da/d41/error_8h.html#a905255056c349318139d94aa4523d516">ErrorCode_t</a> type to indicate success or error condition. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">LPC_OK</td><td>On success </td></tr>
    <tr><td class="paramname">ERR_USBD_TOO_MANY_CLASS_HDLR(0x0004000c)</td><td>The number of class handlers registered is greater than the number of handlers allowed by the stack. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a305d05fbc2d0c748b87edcd986bfb767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305d05fbc2d0c748b87edcd986bfb767">&sect;&nbsp;</a></span>RegisterEpHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d41/error_8h.html#a905255056c349318139d94aa4523d516">ErrorCode_t</a> USBD_CORE_API_T::RegisterEpHandler</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to register interrupt/event handler for the requested endpoint with USB device stack. </p>
<p>The application layer uses this function to register the endpoint event handler. The stack calls all the registered endpoint handlers when</p><ul>
<li>USB_EVT_OUT or USB_EVT_OUT_NAK events happen for OUT endpoint.</li>
<li>USB_EVT_IN or USB_EVT_IN_NAK events happen for IN endpoint. Check USB_EP_HANDLER_T for more details on how the callback function should be implemented. <dl class="section note"><dt>Note</dt><dd>By default endpoint _NAK events are not enabled. Application should call <a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#ac8ba5c7f74d1861430a067375b4af885">USBD_HW_API_T::EnableEvent</a> for the corresponding endpoint.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep_index</td><td>Endpoint index. Computed as<ul>
<li>For OUT endpoints = 2 * endpoint number eg. for EP2_OUT it is 4.</li>
<li>For IN endopoints = (2 * endpoint number) + 1 eg. for EP2_IN it is 5. </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pfn</td><td>Endpoint event handler function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the data which will be passed when callback function is called by the stack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <a class="el" href="../../da/d41/error_8h.html#a905255056c349318139d94aa4523d516">ErrorCode_t</a> type to indicate success or error condition. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">LPC_OK</td><td>On success </td></tr>
    <tr><td class="paramname">ERR_API_INVALID_PARAM2</td><td>ep_index is outside the boundary ( &lt; 2 * <a class="el" href="../../d2/d7f/struct_u_s_b_d___a_p_i___i_n_i_t___p_a_r_a_m___t.html#af9eae0114be0454c4cce831715faf585" title="max number of endpoints supported by the USB device controller instance (specified by usb_reg_base fi...">USBD_API_INIT_PARAM_T::max_num_ep</a>). </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="a373376ee1855114095288c907687b421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373376ee1855114095288c907687b421">&sect;&nbsp;</a></span>SetupStage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_CORE_API_T::SetupStage</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to set EP0 state machine in setup state. </p>
<p>This function is called by USB stack and the application layer to set the EP0 state machine in setup state. This function will read the setup packet received from USB host into stack's buffer. <br />
</p><dl class="section note"><dt>Note</dt><dd>This interface is provided to users to invoke this function in other scenarios which are not handle by current stack. In most user applications this function is not called directly.Also this function can be used by users who are selectively modifying the USB device stack's standard handlers through callback interface exposed by the stack.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="ab1e05c41e0070d3e706ae98e048e4384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e05c41e0070d3e706ae98e048e4384">&sect;&nbsp;</a></span>DataInStage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_CORE_API_T::DataInStage</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to set EP0 state machine in data_in state. </p>
<p>This function is called by USB stack and the application layer to set the EP0 state machine in data_in state. This function will write the data present in EP0Data buffer to EP0 FIFO for transmission to host. <br />
</p><dl class="section note"><dt>Note</dt><dd>This interface is provided to users to invoke this function in other scenarios which are not handle by current stack. In most user applications this function is not called directly.Also this function can be used by users who are selectively modifying the USB device stack's standard handlers through callback interface exposed by the stack.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="aff6e7a43f616cdcbf9e193da25df684a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff6e7a43f616cdcbf9e193da25df684a">&sect;&nbsp;</a></span>DataOutStage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_CORE_API_T::DataOutStage</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to set EP0 state machine in data_out state. </p>
<p>This function is called by USB stack and the application layer to set the EP0 state machine in data_out state. This function will read the control data (EP0 out packets) received from USB host into EP0Data buffer. <br />
</p><dl class="section note"><dt>Note</dt><dd>This interface is provided to users to invoke this function in other scenarios which are not handle by current stack. In most user applications this function is not called directly.Also this function can be used by users who are selectively modifying the USB device stack's standard handlers through callback interface exposed by the stack.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="a714fc392b856668bf6422cfb1ef1d74c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714fc392b856668bf6422cfb1ef1d74c">&sect;&nbsp;</a></span>StatusInStage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_CORE_API_T::StatusInStage</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to set EP0 state machine in status_in state. </p>
<p>This function is called by USB stack and the application layer to set the EP0 state machine in status_in state. This function will send zero length IN packet on EP0 to host, indicating positive status. <br />
</p><dl class="section note"><dt>Note</dt><dd>This interface is provided to users to invoke this function in other scenarios which are not handle by current stack. In most user applications this function is not called directly.Also this function can be used by users who are selectively modifying the USB device stack's standard handlers through callback interface exposed by the stack.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="a3c49c88a0f39ad432b7ddd03ae449403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c49c88a0f39ad432b7ddd03ae449403">&sect;&nbsp;</a></span>StatusOutStage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_CORE_API_T::StatusOutStage</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to set EP0 state machine in status_out state. </p>
<p>This function is called by USB stack and the application layer to set the EP0 state machine in status_out state. This function will read the zero length OUT packet received from USB host on EP0. <br />
</p><dl class="section note"><dt>Note</dt><dd>This interface is provided to users to invoke this function in other scenarios which are not handle by current stack. In most user applications this function is not called directly.Also this function can be used by users who are selectively modifying the USB device stack's standard handlers through callback interface exposed by the stack.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="adbfe3149090b63dd0334634f5f08b002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbfe3149090b63dd0334634f5f08b002">&sect;&nbsp;</a></span>StallEp0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_CORE_API_T::StallEp0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to set EP0 state machine in stall state. </p>
<p>This function is called by USB stack and the application layer to generate STALL signaling on EP0 endpoint. This function will also reset the EP0Data buffer. <br />
</p><dl class="section note"><dt>Note</dt><dd>This interface is provided to users to invoke this function in other scenarios which are not handle by current stack. In most user applications this function is not called directly.Also this function can be used by users who are selectively modifying the USB device stack's standard handlers through callback interface exposed by the stack.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="a48c164125955a57eacb5e463a566e39e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c164125955a57eacb5e463a566e39e">&sect;&nbsp;</a></span>GetEpHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d41/error_8h.html#a905255056c349318139d94aa4523d516">ErrorCode_t</a> USBD_CORE_API_T::GetEpHandler</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get default EP handler and its parameter for a particular endpoint. </p>
<p>This function is called by the application layer to retrieve the default Endpoint Handler and its data parameter for a particular endpoint. <br />
</p><dl class="section note"><dt>Note</dt><dd>This interface is provided so that the application could get the default handler, then register their own endpoint handler to do some special handling and then call the default handler.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep_index</td><td>Endpoint index. Computed as<ul>
<li>For OUT endpoints = 2 * endpoint number eg. for EP2_OUT it is 4.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>For IN endopoints = (2 * endpoint number) + 1 eg. for EP2_IN it is 5. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ep_handler</td><td>Double Pointer to Endpoint event handler function which is updated in the function. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Double Pointer to the data parameter that needs to be passed when calling the event handler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <a class="el" href="../../da/d41/error_8h.html#a905255056c349318139d94aa4523d516">ErrorCode_t</a> type to indicate success or error condition. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">LPC_OK</td><td>On success </td></tr>
    <tr><td class="paramname">ERR_API_INVALID_PARAM2</td><td>ep_index is outside the boundary ( &lt; 2 * <a class="el" href="../../d2/d7f/struct_u_s_b_d___a_p_i___i_n_i_t___p_a_r_a_m___t.html#af9eae0114be0454c4cce831715faf585" title="max number of endpoints supported by the USB device controller instance (specified by usb_reg_base fi...">USBD_API_INIT_PARAM_T::max_num_ep</a>). </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>external/USBD_ROMStack/inc/<a class="el" href="../../dc/dc1/mw__usbd__core_8h.html">mw_usbd_core.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../de/d08/struct_u_s_b_d___c_o_r_e___a_p_i___t.html">USBD_CORE_API_T</a></li>
    <li class="footer">Generated on Fri Nov 23 2018 14:38:31 for PN7462AU FW API Guide by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>

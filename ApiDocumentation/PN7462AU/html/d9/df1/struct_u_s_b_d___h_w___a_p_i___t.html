<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PN7462AU FW API Guide: USBD_HW_API_T Struct Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../nxp_logo_s.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PN7462AU FW API Guide
   &#160;<span id="projectnumber">v04.14.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html','../../');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">USBD_HW_API_T Struct Reference<div class="ingroups"><a class="el" href="../../da/d5b/group___group___u_s_b_d.html">USB Library</a> &raquo; <a class="el" href="../../d2/dcf/group___u_s_b_d___h_w.html">USB Device Controller Driver</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Hardware API functions structure.  
 <a href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for USBD_HW_API_T:</div>
<div class="dyncontent">
<div class="center"><img src="../../d9/dbb/struct_u_s_b_d___h_w___a_p_i___t__coll__graph.png" border="0" usemap="#_u_s_b_d___h_w___a_p_i___t_coll__map" alt="Collaboration graph"/></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a0139f290b9605de953245f12b5a0ff26"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#a0139f290b9605de953245f12b5a0ff26">GetMemSize</a> )(<a class="el" href="../../d2/d7f/struct_u_s_b_d___a_p_i___i_n_i_t___p_a_r_a_m___t.html">USBD_API_INIT_PARAM_T</a> *param)</td></tr>
<tr class="memdesc:a0139f290b9605de953245f12b5a0ff26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to determine the memory required by the USB device stack's DCD and core layers.  <a href="#a0139f290b9605de953245f12b5a0ff26">More...</a><br /></td></tr>
<tr class="separator:a0139f290b9605de953245f12b5a0ff26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7b0f0dc37399c73b3cb03224a6715c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d41/error_8h.html#a905255056c349318139d94aa4523d516">ErrorCode_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#adf7b0f0dc37399c73b3cb03224a6715c">Init</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> *phUsb, <a class="el" href="../../d1/d9a/struct_u_s_b___c_o_r_e___d_e_s_c_s___t.html">USB_CORE_DESCS_T</a> *pDesc, <a class="el" href="../../d2/d7f/struct_u_s_b_d___a_p_i___i_n_i_t___p_a_r_a_m___t.html">USBD_API_INIT_PARAM_T</a> *param)</td></tr>
<tr class="memdesc:adf7b0f0dc37399c73b3cb03224a6715c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize USB device stack's DCD and core layers.  <a href="#adf7b0f0dc37399c73b3cb03224a6715c">More...</a><br /></td></tr>
<tr class="separator:adf7b0f0dc37399c73b3cb03224a6715c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f866b8fdcb6c08b622badfa5703545"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#a94f866b8fdcb6c08b622badfa5703545">Connect</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t con)</td></tr>
<tr class="memdesc:a94f866b8fdcb6c08b622badfa5703545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make USB device visible/invisible on the USB bus.  <a href="#a94f866b8fdcb6c08b622badfa5703545">More...</a><br /></td></tr>
<tr class="separator:a94f866b8fdcb6c08b622badfa5703545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d85b9c68f1ec92c8092dafe524fe2b"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#a00d85b9c68f1ec92c8092dafe524fe2b">ISR</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb)</td></tr>
<tr class="memdesc:a00d85b9c68f1ec92c8092dafe524fe2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to USB device controller interrupt events.  <a href="#a00d85b9c68f1ec92c8092dafe524fe2b">More...</a><br /></td></tr>
<tr class="separator:a00d85b9c68f1ec92c8092dafe524fe2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8865aa13798d88076d1f60e4aa05ffd"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#aa8865aa13798d88076d1f60e4aa05ffd">Reset</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb)</td></tr>
<tr class="memdesc:aa8865aa13798d88076d1f60e4aa05ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to Reset USB device stack and hardware controller.  <a href="#aa8865aa13798d88076d1f60e4aa05ffd">More...</a><br /></td></tr>
<tr class="separator:aa8865aa13798d88076d1f60e4aa05ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4fda1a2255a941af2defbaf43ec6fc2"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#ac4fda1a2255a941af2defbaf43ec6fc2">ForceFullSpeed</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t cfg)</td></tr>
<tr class="memdesc:ac4fda1a2255a941af2defbaf43ec6fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to force high speed USB device to operate in full speed mode.  <a href="#ac4fda1a2255a941af2defbaf43ec6fc2">More...</a><br /></td></tr>
<tr class="separator:ac4fda1a2255a941af2defbaf43ec6fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303ebdddeba4fbe77a9bf82d10829d06"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#a303ebdddeba4fbe77a9bf82d10829d06">WakeUpCfg</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t cfg)</td></tr>
<tr class="memdesc:a303ebdddeba4fbe77a9bf82d10829d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to configure USB device controller to wake-up host on remote events.  <a href="#a303ebdddeba4fbe77a9bf82d10829d06">More...</a><br /></td></tr>
<tr class="separator:a303ebdddeba4fbe77a9bf82d10829d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac740eff46c33a2e55505d38b78bbc15"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#aac740eff46c33a2e55505d38b78bbc15">SetAddress</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t adr)</td></tr>
<tr class="memdesc:aac740eff46c33a2e55505d38b78bbc15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set USB address assigned by host in device controller hardware.  <a href="#aac740eff46c33a2e55505d38b78bbc15">More...</a><br /></td></tr>
<tr class="separator:aac740eff46c33a2e55505d38b78bbc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ff45a427052dd46f20f01e00ec759c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#a14ff45a427052dd46f20f01e00ec759c">Configure</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t cfg)</td></tr>
<tr class="memdesc:a14ff45a427052dd46f20f01e00ec759c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to configure device controller hardware with selected configuration.  <a href="#a14ff45a427052dd46f20f01e00ec759c">More...</a><br /></td></tr>
<tr class="separator:a14ff45a427052dd46f20f01e00ec759c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05143cf85edf626e786ae3a24be105e2"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#a05143cf85edf626e786ae3a24be105e2">ConfigEP</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, USB_ENDPOINT_DESCRIPTOR *pEPD)</td></tr>
<tr class="memdesc:a05143cf85edf626e786ae3a24be105e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to configure USB Endpoint according to descriptor.  <a href="#a05143cf85edf626e786ae3a24be105e2">More...</a><br /></td></tr>
<tr class="separator:a05143cf85edf626e786ae3a24be105e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95b4205de9657a5f5bba6aafd5c9b1b"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#ab95b4205de9657a5f5bba6aafd5c9b1b">DirCtrlEP</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t dir)</td></tr>
<tr class="memdesc:ab95b4205de9657a5f5bba6aafd5c9b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set direction for USB control endpoint EP0.  <a href="#ab95b4205de9657a5f5bba6aafd5c9b1b">More...</a><br /></td></tr>
<tr class="separator:ab95b4205de9657a5f5bba6aafd5c9b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed5cd50bbf5612c2ca6515482119f14"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#a2ed5cd50bbf5612c2ca6515482119f14">EnableEP</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t EPNum)</td></tr>
<tr class="memdesc:a2ed5cd50bbf5612c2ca6515482119f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to enable selected USB endpoint.  <a href="#a2ed5cd50bbf5612c2ca6515482119f14">More...</a><br /></td></tr>
<tr class="separator:a2ed5cd50bbf5612c2ca6515482119f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f346a7f9024f17e4def61e15b5db1b6"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#a1f346a7f9024f17e4def61e15b5db1b6">DisableEP</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t EPNum)</td></tr>
<tr class="memdesc:a1f346a7f9024f17e4def61e15b5db1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to disable selected USB endpoint.  <a href="#a1f346a7f9024f17e4def61e15b5db1b6">More...</a><br /></td></tr>
<tr class="separator:a1f346a7f9024f17e4def61e15b5db1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf39abc4c1d2bbf0de4800fcaee74f7e"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#aaf39abc4c1d2bbf0de4800fcaee74f7e">ResetEP</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t EPNum)</td></tr>
<tr class="memdesc:aaf39abc4c1d2bbf0de4800fcaee74f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to reset selected USB endpoint.  <a href="#aaf39abc4c1d2bbf0de4800fcaee74f7e">More...</a><br /></td></tr>
<tr class="separator:aaf39abc4c1d2bbf0de4800fcaee74f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120a026986cd54f2ebac307bfe7298ed"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#a120a026986cd54f2ebac307bfe7298ed">SetStallEP</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t EPNum)</td></tr>
<tr class="memdesc:a120a026986cd54f2ebac307bfe7298ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to STALL selected USB endpoint.  <a href="#a120a026986cd54f2ebac307bfe7298ed">More...</a><br /></td></tr>
<tr class="separator:a120a026986cd54f2ebac307bfe7298ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1c9298a6c41d175a26e6c7cfa644a8"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#a8f1c9298a6c41d175a26e6c7cfa644a8">ClrStallEP</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t EPNum)</td></tr>
<tr class="memdesc:a8f1c9298a6c41d175a26e6c7cfa644a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to clear STALL state for the requested endpoint.  <a href="#a8f1c9298a6c41d175a26e6c7cfa644a8">More...</a><br /></td></tr>
<tr class="separator:a8f1c9298a6c41d175a26e6c7cfa644a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29373feb1c7b6a6be1eb82884a48478"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d41/error_8h.html#a905255056c349318139d94aa4523d516">ErrorCode_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#ad29373feb1c7b6a6be1eb82884a48478">SetTestMode</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint8_t mode)</td></tr>
<tr class="memdesc:ad29373feb1c7b6a6be1eb82884a48478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set high speed USB device controller in requested test mode.  <a href="#ad29373feb1c7b6a6be1eb82884a48478">More...</a><br /></td></tr>
<tr class="separator:ad29373feb1c7b6a6be1eb82884a48478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563550e0a99ee45b29c4aaa7a1f57e1d"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#a563550e0a99ee45b29c4aaa7a1f57e1d">ReadEP</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t EPNum, uint8_t *pData)</td></tr>
<tr class="memdesc:a563550e0a99ee45b29c4aaa7a1f57e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to read data received on the requested endpoint.  <a href="#a563550e0a99ee45b29c4aaa7a1f57e1d">More...</a><br /></td></tr>
<tr class="separator:a563550e0a99ee45b29c4aaa7a1f57e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9430c42695d6d31f626dc72d69fb69ad"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#a9430c42695d6d31f626dc72d69fb69ad">ReadReqEP</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t EPNum, uint8_t *pData, uint32_t len)</td></tr>
<tr class="memdesc:a9430c42695d6d31f626dc72d69fb69ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to queue read request on the specified endpoint.  <a href="#a9430c42695d6d31f626dc72d69fb69ad">More...</a><br /></td></tr>
<tr class="separator:a9430c42695d6d31f626dc72d69fb69ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdd89766fb47d106014234d6fc96092"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#a4cdd89766fb47d106014234d6fc96092">ReadSetupPkt</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t EPNum, uint32_t *pData)</td></tr>
<tr class="memdesc:a4cdd89766fb47d106014234d6fc96092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to read setup packet data received on the requested endpoint.  <a href="#a4cdd89766fb47d106014234d6fc96092">More...</a><br /></td></tr>
<tr class="separator:a4cdd89766fb47d106014234d6fc96092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0f044c14779dca4425403e2a50991c"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#aac0f044c14779dca4425403e2a50991c">WriteEP</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t EPNum, uint8_t *pData, uint32_t cnt)</td></tr>
<tr class="memdesc:aac0f044c14779dca4425403e2a50991c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to write data to be sent on the requested endpoint.  <a href="#aac0f044c14779dca4425403e2a50991c">More...</a><br /></td></tr>
<tr class="separator:aac0f044c14779dca4425403e2a50991c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e8e27a0733b22a2ac797a462bd52be"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#aa4e8e27a0733b22a2ac797a462bd52be">WakeUp</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb)</td></tr>
<tr class="memdesc:aa4e8e27a0733b22a2ac797a462bd52be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to generate resume signaling on bus for remote host wakeup.  <a href="#aa4e8e27a0733b22a2ac797a462bd52be">More...</a><br /></td></tr>
<tr class="separator:aa4e8e27a0733b22a2ac797a462bd52be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ba5c7f74d1861430a067375b4af885"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d41/error_8h.html#a905255056c349318139d94aa4523d516">ErrorCode_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#ac8ba5c7f74d1861430a067375b4af885">EnableEvent</a> )(<a class="el" href="../../d0/d8f/group___u_s_b_d___core.html#gafdbb2204d929cb9d75736bd2b42342ac">USBD_HANDLE_T</a> hUsb, uint32_t EPNum, uint32_t event_type, uint32_t enable)</td></tr>
<tr class="memdesc:ac8ba5c7f74d1861430a067375b4af885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to enable/disable selected USB event.  <a href="#ac8ba5c7f74d1861430a067375b4af885">More...</a><br /></td></tr>
<tr class="separator:ac8ba5c7f74d1861430a067375b4af885"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Hardware API functions structure. </p>
<p>This module exposes functions which interact directly with USB device controller hardware. </p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="a0139f290b9605de953245f12b5a0ff26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0139f290b9605de953245f12b5a0ff26">&sect;&nbsp;</a></span>GetMemSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBD_HW_API_T::GetMemSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to determine the memory required by the USB device stack's DCD and core layers. </p>
<p>This function is called by application layer before calling pUsbApi-&gt;hw-&gt;<a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#adf7b0f0dc37399c73b3cb03224a6715c" title="Function to initialize USB device stack&#39;s DCD and core layers. ">Init()</a>, to allocate memory used by DCD and core layers. The application should allocate the memory which is accessible by USB controller/DMA controller. </p><dl class="section note"><dt>Note</dt><dd>Some memory areas are not accessible by all bus masters.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Structure containing USB device stack initialization parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the required memory size in bytes. </dd></dl>

</div>
</div>
<a id="adf7b0f0dc37399c73b3cb03224a6715c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf7b0f0dc37399c73b3cb03224a6715c">&sect;&nbsp;</a></span>Init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d41/error_8h.html#a905255056c349318139d94aa4523d516">ErrorCode_t</a> USBD_HW_API_T::Init</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize USB device stack's DCD and core layers. </p>
<p>This function is called by application layer to initialize USB hardware and core layers. On successful initialization the function returns a handle to USB device stack which should be passed to the rest of the functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">phUsb</td><td>Pointer to the USB device stack handle of type USBD_HANDLE_T. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pDesc</td><td>Structure containing pointers to various descriptor arrays needed by the stack. These descriptors are reported to USB host as part of enumerations process. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Structure containing USB device stack initialization parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <a class="el" href="../../da/d41/error_8h.html#a905255056c349318139d94aa4523d516">ErrorCode_t</a> type to indicate success or error condition. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">LPC_OK(0)</td><td>On success </td></tr>
    <tr><td class="paramname">ERR_USBD_BAD_MEM_BUF(0x0004000b)</td><td>When insufficient memory buffer is passed or memory is not aligned on 2048 boundary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94f866b8fdcb6c08b622badfa5703545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f866b8fdcb6c08b622badfa5703545">&sect;&nbsp;</a></span>Connect</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_HW_API_T::Connect</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to make USB device visible/invisible on the USB bus. </p>
<p>This function is called after the USB initialization. This function uses the soft connect feature to make the device visible on the USB bus. This function is called only after the application is ready to handle the USB data. The enumeration process is started by the host after the device detection. The driver handles the enumeration process according to the USB descriptors passed in the USB initialization function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">con</td><td>States whether to connect (1) or to disconnect (0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="a00d85b9c68f1ec92c8092dafe524fe2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d85b9c68f1ec92c8092dafe524fe2b">&sect;&nbsp;</a></span>ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_HW_API_T::ISR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to USB device controller interrupt events. </p>
<p>When the user application is active the interrupt handlers are mapped in the user flash space. The user application must provide an interrupt handler for the USB interrupt and call this function in the interrupt handler routine. The driver interrupt handler takes appropriate action according to the data received on the USB bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="aa8865aa13798d88076d1f60e4aa05ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8865aa13798d88076d1f60e4aa05ffd">&sect;&nbsp;</a></span>Reset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_HW_API_T::Reset</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to Reset USB device stack and hardware controller. </p>
<p>Reset USB device stack and hardware controller. Disables all endpoints except EP0. Clears all pending interrupts and resets endpoint transfer queues. This function is called internally by pUsbApi-&gt;hw-&gt;init() and from reset event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="ac4fda1a2255a941af2defbaf43ec6fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4fda1a2255a941af2defbaf43ec6fc2">&sect;&nbsp;</a></span>ForceFullSpeed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_HW_API_T::ForceFullSpeed</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to force high speed USB device to operate in full speed mode. </p>
<p>This function is useful for testing the behavior of current device when connected to a full speed only hosts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cfg</td><td>When 1 - set force full-speed or 0 - clear force full-speed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="a303ebdddeba4fbe77a9bf82d10829d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303ebdddeba4fbe77a9bf82d10829d06">&sect;&nbsp;</a></span>WakeUpCfg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_HW_API_T::WakeUpCfg</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to configure USB device controller to wake-up host on remote events. </p>
<p>This function is called by application layer to configure the USB device controller to wakeup on remote events. It is recommended to call this function from users's USB_WakeUpCfg() callback routine registered with stack. </p><dl class="section note"><dt>Note</dt><dd>User's USB_WakeUpCfg() is registered with stack by setting the USB_WakeUpCfg member of <a class="el" href="../../d2/d7f/struct_u_s_b_d___a_p_i___i_n_i_t___p_a_r_a_m___t.html" title="USB device stack initialization parameter data structure. ">USBD_API_INIT_PARAM_T</a> structure before calling pUsbApi-&gt;hw-&gt;<a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#adf7b0f0dc37399c73b3cb03224a6715c" title="Function to initialize USB device stack&#39;s DCD and core layers. ">Init()</a> routine. Certain USB device controllers needed to keep some clocks always on to generate resume signaling through pUsbApi-&gt;hw-&gt;<a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html#aa4e8e27a0733b22a2ac797a462bd52be" title="Function to generate resume signaling on bus for remote host wakeup. ">WakeUp()</a>. This hook is provided to support such controllers. In most controllers cases this is an empty routine.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cfg</td><td>When 1 - Configure controller to wake on remote events or 0 - Configure controller not to wake on remote events. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="aac740eff46c33a2e55505d38b78bbc15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac740eff46c33a2e55505d38b78bbc15">&sect;&nbsp;</a></span>SetAddress</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_HW_API_T::SetAddress</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to set USB address assigned by host in device controller hardware. </p>
<p>This function is called automatically when USB_REQUEST_SET_ADDRESS request is received by the stack from USB host. This interface is provided to users to invoke this function in other scenarios which are not handle by current stack. In most user applications this function is not called directly. Also this function can be used by users who are selectively modifying the USB device stack's standard handlers through callback interface exposed by the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">adr</td><td>USB bus Address to which the device controller should respond. Usually assigned by the USB host. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="a14ff45a427052dd46f20f01e00ec759c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ff45a427052dd46f20f01e00ec759c">&sect;&nbsp;</a></span>Configure</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_HW_API_T::Configure</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to configure device controller hardware with selected configuration. </p>
<p>This function is called automatically when USB_REQUEST_SET_CONFIGURATION request is received by the stack from USB host. This interface is provided to users to invoke this function in other scenarios which are not handle by current stack. In most user applications this function is not called directly. Also this function can be used by users who are selectively modifying the USB device stack's standard handlers through callback interface exposed by the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cfg</td><td>Configuration index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="a05143cf85edf626e786ae3a24be105e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05143cf85edf626e786ae3a24be105e2">&sect;&nbsp;</a></span>ConfigEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_HW_API_T::ConfigEP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to configure USB Endpoint according to descriptor. </p>
<p>This function is called automatically when USB_REQUEST_SET_CONFIGURATION request is received by the stack from USB host. All the endpoints associated with the selected configuration are configured. This interface is provided to users to invoke this function in other scenarios which are not handle by current stack. In most user applications this function is not called directly. Also this function can be used by users who are selectively modifying the USB device stack's standard handlers through callback interface exposed by the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEPD</td><td>Endpoint descriptor structure defined in USB 2.0 specification. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="ab95b4205de9657a5f5bba6aafd5c9b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab95b4205de9657a5f5bba6aafd5c9b1b">&sect;&nbsp;</a></span>DirCtrlEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_HW_API_T::DirCtrlEP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to set direction for USB control endpoint EP0. </p>
<p>This function is called automatically by the stack on need basis. This interface is provided to users to invoke this function in other scenarios which are not handle by current stack. In most user applications this function is not called directly. Also this function can be used by users who are selectively modifying the USB device stack's standard handlers through callback interface exposed by the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cfg</td><td>When 1 - Set EP0 in IN transfer mode 0 - Set EP0 in OUT transfer mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="a2ed5cd50bbf5612c2ca6515482119f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed5cd50bbf5612c2ca6515482119f14">&sect;&nbsp;</a></span>EnableEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_HW_API_T::EnableEP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to enable selected USB endpoint. </p>
<p>This function enables interrupts on selected endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EPNum</td><td>Endpoint number as per USB specification. ie. An EP1_IN is represented by 0x81 number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="a1f346a7f9024f17e4def61e15b5db1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f346a7f9024f17e4def61e15b5db1b6">&sect;&nbsp;</a></span>DisableEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_HW_API_T::DisableEP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to disable selected USB endpoint. </p>
<p>This function disables interrupts on selected endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EPNum</td><td>Endpoint number as per USB specification. ie. An EP1_IN is represented by 0x81 number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="aaf39abc4c1d2bbf0de4800fcaee74f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf39abc4c1d2bbf0de4800fcaee74f7e">&sect;&nbsp;</a></span>ResetEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_HW_API_T::ResetEP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to reset selected USB endpoint. </p>
<p>This function flushes the endpoint buffers and resets data toggle logic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EPNum</td><td>Endpoint number as per USB specification. ie. An EP1_IN is represented by 0x81 number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="a120a026986cd54f2ebac307bfe7298ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120a026986cd54f2ebac307bfe7298ed">&sect;&nbsp;</a></span>SetStallEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_HW_API_T::SetStallEP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to STALL selected USB endpoint. </p>
<p>Generates STALL signaling for requested endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EPNum</td><td>Endpoint number as per USB specification. ie. An EP1_IN is represented by 0x81 number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="a8f1c9298a6c41d175a26e6c7cfa644a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f1c9298a6c41d175a26e6c7cfa644a8">&sect;&nbsp;</a></span>ClrStallEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_HW_API_T::ClrStallEP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to clear STALL state for the requested endpoint. </p>
<p>This function clears STALL state for the requested endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EPNum</td><td>Endpoint number as per USB specification. ie. An EP1_IN is represented by 0x81 number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="ad29373feb1c7b6a6be1eb82884a48478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29373feb1c7b6a6be1eb82884a48478">&sect;&nbsp;</a></span>SetTestMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d41/error_8h.html#a905255056c349318139d94aa4523d516">ErrorCode_t</a> USBD_HW_API_T::SetTestMode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to set high speed USB device controller in requested test mode. </p>
<p>USB-IF requires the high speed device to be put in various test modes for electrical testing. This USB device stack calls this function whenever it receives USB_REQUEST_CLEAR_FEATURE request for USB_FEATURE_TEST_MODE. Users can put the device in test mode by directly calling this function. Returns ERR_USBD_INVALID_REQ when device controller is full-speed only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Test mode defined in USB 2.0 electrical testing specification. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <a class="el" href="../../da/d41/error_8h.html#a905255056c349318139d94aa4523d516">ErrorCode_t</a> type to indicate success or error condition. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">LPC_OK(0)</td><td>- On success </td></tr>
    <tr><td class="paramname">ERR_USBD_INVALID_REQ(0x00040001)</td><td>- Invalid test mode or Device controller is full-speed only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a563550e0a99ee45b29c4aaa7a1f57e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563550e0a99ee45b29c4aaa7a1f57e1d">&sect;&nbsp;</a></span>ReadEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBD_HW_API_T::ReadEP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to read data received on the requested endpoint. </p>
<p>This function is called by USB stack and the application layer to read the data received on the requested endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EPNum</td><td>Endpoint number as per USB specification. ie. An EP1_IN is represented by 0x81 number. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pData</td><td>Pointer to the data buffer where data is to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes copied to the buffer. </dd></dl>

</div>
</div>
<a id="a9430c42695d6d31f626dc72d69fb69ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9430c42695d6d31f626dc72d69fb69ad">&sect;&nbsp;</a></span>ReadReqEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBD_HW_API_T::ReadReqEP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to queue read request on the specified endpoint. </p>
<p>This function is called by USB stack and the application layer to queue a read request on the specified endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EPNum</td><td>Endpoint number as per USB specification. ie. An EP1_IN is represented by 0x81 number. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pData</td><td>Pointer to the data buffer where data is to be copied. This buffer address should be accessible by USB DMA master. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the buffer passed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the length of the requested buffer. </dd></dl>

</div>
</div>
<a id="a4cdd89766fb47d106014234d6fc96092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cdd89766fb47d106014234d6fc96092">&sect;&nbsp;</a></span>ReadSetupPkt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBD_HW_API_T::ReadSetupPkt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to read setup packet data received on the requested endpoint. </p>
<p>This function is called by USB stack and the application layer to read setup packet data received on the requested endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EPNum</td><td>Endpoint number as per USB specification. ie. An EP0_IN is represented by 0x80 number. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pData</td><td>Pointer to the data buffer where data is to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes copied to the buffer. </dd></dl>

</div>
</div>
<a id="aac0f044c14779dca4425403e2a50991c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0f044c14779dca4425403e2a50991c">&sect;&nbsp;</a></span>WriteEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBD_HW_API_T::WriteEP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to write data to be sent on the requested endpoint. </p>
<p>This function is called by USB stack and the application layer to send data on the requested endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EPNum</td><td>Endpoint number as per USB specification. ie. An EP1_IN is represented by 0x81 number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pData</td><td>Pointer to the data buffer from where data is to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cnt</td><td>Number of bytes to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes written. </dd></dl>

</div>
</div>
<a id="aa4e8e27a0733b22a2ac797a462bd52be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e8e27a0733b22a2ac797a462bd52be">&sect;&nbsp;</a></span>WakeUp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_HW_API_T::WakeUp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to generate resume signaling on bus for remote host wakeup. </p>
<p>This function is called by application layer to remotely wakeup host controller when system is in suspend state. Application should indicate this remote wakeup capability by setting USB_CONFIG_REMOTE_WAKEUP in bmAttributes of Configuration Descriptor. Also this routine will generate resume signalling only if host enables USB_FEATURE_REMOTE_WAKEUP by sending SET_FEATURE request before suspending the bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="ac8ba5c7f74d1861430a067375b4af885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ba5c7f74d1861430a067375b4af885">&sect;&nbsp;</a></span>EnableEvent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_HW_API_T::EnableEvent</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to enable/disable selected USB event. </p>
<p>This function enables interrupts on selected endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hUsb</td><td>Handle to the USB device stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EPNum</td><td>Endpoint number corresponding to the event. ie. An EP1_IN is represented by 0x81 number. For device events set this param to 0x0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event_type</td><td>Type of endpoint event. See <a class="el" href="../../d2/dcf/group___u_s_b_d___h_w.html#ga61dde6aa35d2912927ef1b185eedaa13">USBD_EVENT_T</a> for more details. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>1 - enable event, 0 - disable event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <a class="el" href="../../da/d41/error_8h.html#a905255056c349318139d94aa4523d516">ErrorCode_t</a> type to indicate success or error condition. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">LPC_OK(0)</td><td>- On success </td></tr>
    <tr><td class="paramname">ERR_USBD_INVALID_REQ(0x00040001)</td><td>- Invalid event type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>external/USBD_ROMStack/inc/<a class="el" href="../../d1/d72/mw__usbd__hw_8h.html">mw_usbd_hw.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d9/df1/struct_u_s_b_d___h_w___a_p_i___t.html">USBD_HW_API_T</a></li>
    <li class="footer">Generated on Fri Nov 23 2018 14:38:31 for PN7462AU FW API Guide by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
